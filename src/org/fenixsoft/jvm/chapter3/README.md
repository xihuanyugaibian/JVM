程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基本概念模型的讨论里，大体上可以认为是编译期可知的)
，因此在这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。  
Java堆和方法区这两个区域有很明显的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

## 对象已死？

### 引用计数法算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用的。  
引用计数算法虽然占用了一些额外的内存空间，但它原理简单，判定效率高，在大多数情况下它都是一个不错的算法。但是在Java领域，至少主流Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须配合大量的额外处理才能保证正确地工作，譬如对象直接相互循环引用的问题。

### 可达性分析算法

当前主流的商用程序语言(Java、C#、Lisp)的内存管理子系统都是通过可达性分析(Reachability Analysis)算法来判断对象是否存活的。这个算法的基本思路就是通过一系列的"GC Roots"
的跟对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)，如果某个对象的到GC Roots间没有任何引用链或则和用图论的话来说就是从GC
Roots到这个对象不可达时，则证明此对象不可能再被使用。  
在Java技术体系中，固定可作为GC Roots的对象有

* 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
* 在方法区中常量引用的对象，譬如字符串常量池里的引用。
* 在本地方法栈中JNI引用的对象。
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻异常对象(NullPointException、OutOfMemoryError)，系统类加载器。
* 所有被同步锁持有的对象。
* 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

除了固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。

### 再谈引用

判断对象是否存活都和引用离不开关系。在JDK1.2版本之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用和虚引用四种，这四种引用强度依次逐渐减弱。

* 强引用(Strongly Reference)：在程序代码中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
* 软引用(Soft Reference)：用来描述一些还有用，但非必须的对象。只被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围之中，进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* 弱引用(Weak Reference)：描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* 虚引用(Phantom Reference)
  ：也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 生存还是死亡？

在可达性分析算法中判定为不可达的对象，也不是非死不可的，这时候它们还处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC
Roots相连接的引用链，那它会被第一次标记，随后进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖该方法或者该方法已经被虚拟机调用过，那么虚拟机将其视为"没有必要执行"finalize()
方法然后进行第二次标记，也就是宣告对象死亡。  
如果对象被判定为有必要执行finalize()方法，该对象会被放置在一个名为F-Quence的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()
方法。这里虚拟机会触发该方法的执行，并不保证一定会等待它运行结束。  
不建议使用该方法，知道就行。

### 回收方法区

在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%~99%的内存空间，相比方法区回收由于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。  
方法区的垃圾收集主要回收两部分的内容：废弃的常量和不再使用的类型。

## 垃圾收集算法

主要基于追踪式垃圾收集的范畴。

### 分代收集理论

分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上。

* 弱分代假说：绝大多数对象都是朝生夕灭的。
* 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个假说共同奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(熬过垃圾收集过程的次数)分配到不同的区域之中存储。  
在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因而才有了Minor GC、Major GC、Full GC
这样回收类型的划分，也才能够针对不同的区域，安排与里面对象存亡特征相匹配的垃圾收集算法。因而发展除了 标记-复制算法、标记-清除算法、标记-整理算法。

对象不是孤立的，对象之间会存在跨代引用。新生代中的对象完全有可能被老年代所引用，为了找出该区域中的存活对象，不得不在固定的GC
Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也一样，这会为内存回收带来很大的性能负担。为了解决这个问题，需要为分代收集理论添加第三条经验法则：

* 跨代引用假说：跨代引用相对于同代引用来说仅占少数。(存在互相引用关系的两个对象，应该倾向于同时生存或者同时消亡。因为如果存在随着GC次数，新生代的年龄变大是会进入老年代的，这时就不存在跨代了)

依据这条假说，局不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在哪些跨代引用，只需在新生代上建立一个全局的数据结构，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后每当发生Minor
GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

名词定义：

* 部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集。
  * 新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。
  * 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。（目前只有CMS收集器会有单独收集老年代的行为）
  * 混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
* 整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。

### 标记-清除算法

算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。也可以反过来标记存活的对象，回收所有未被标记的对象。

缺点：

* 执行效率不稳定，如果Java堆包含大量对象，而且其中大部分需要被回收，就会有大量的标记和清除动作。
* 内存空间碎片化问题。

### 标记-复制算法

将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把该空间一次清理掉。  
复制回收算法的代价是将可用内存缩小为原来的一半，空间浪费较大。  
新生代中的对象98%熬不过第一轮收集，因此不需要按照1：1的比例来划分新生代的内存空间。

半区复制分代策略：也称Appel式回收，把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。
HotSpot虚拟机默认Eden和Survivor的大小比例8:1，也即是每次新生代中可用内存空间为整个新生代容量的90%，只有一个Survivor空间被保留。当Survivor空间不足以容纳一次Minor
GC之后存活的对象时，就需要依赖其他内存区域（一般指老年代）进行分配担保。

### 标记-整理算法

标记-清除算法和标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配时更复杂。  
因为老年代对象存活率高，移动就移动的对象比较多，不移动有碎片再分配时不好分。有一种和稀泥的解决方案，让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。

## HotSpot的算法细节实现

### 根节点枚举

可达性分析算法从GC Roots集合找引用链。固定可作为GC Roots的节点主要在全局性的引用（常量或类静态属性）与执行上下文（栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情。  
迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到和用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行。  
目前主流的Java虚拟机使用的都是准确式垃圾收集，当用户线程停顿下来之后，其实并不需要一个不漏地检查所有执行上下文和全局的引用位置，虚拟机应该是有办法直接得到哪些地方存放着对象引用。  
HotSpot是使用一组称为OopMap的数据结构（OOP：Ordinary Object Pointer
普通对象指针），一旦类加载工作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在<u>特定的位置</u>记录下
栈里和寄存器里哪些位置是引用，这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots来时查找。

### 安全点

在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但是 导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，将会需要大量的额外空间。  
HotSpot并没有为每条指令都生成OopMap，只是在特性的位置记录了这些信息,这些位置被称为**安全点**。   
有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此 安全点的选定也不是随意的基本上是以”是否具有让程序长时间执行的特征“为标准进行选定的。
长时间执行的最明显特征就是指令序列的复用，例如方法调用，循环跳转，异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

如何在垃圾收集发生时让所有线程（不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。

* 抢先式中断：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程去执行，让它一会再重新中断，直到跑到安全点上。（几乎没有虚拟机用这种方式）
* 主动式中断：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

线程发生轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这时为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。
由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编执行的程度。
当需要暂定用户线程时，虚拟机把某个内存页设置为不可读，当线程执行到对应指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。

### 安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是程序不执行的时候（没有分配处理器时间）当用户线程处于Sleep或者Blocked状态，此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断自己，对于这种情况，引入了安全区域。

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域任意地方开始垃圾收集都是安全的。  
当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，这段时间虚拟机要发生垃圾收集就不必去管这些线程。当线程要离开安全区域时，它要检查虚拟机是否已经完成根节点枚举，完成了就继续执行；否则就必须等待。

### 记忆集与卡表

为了解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。  
事实上并不只是新生代和老年代之间才有跨代引用，所有设计**部分区域收集**行为的垃圾收集器都会面临相同的问题。

记忆集是一种用于记录从非收集区域执行手机区域的指针集合的抽象数据结构。  
在垃圾收集场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。  
设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本。

* 字长精度：每个记录精确到一个机器字长，该字包含跨代指针。
* 对象进度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
* 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

卡精度所指的是一种称为卡表的方式去实现记忆集，也是目前常用的一种记忆集实现方式。  
卡表定义了记忆集的记录精度与堆内存的映射关系等。卡表中的每个元素都对应这标识的内存区域中一块特定大小的内存块（卡页）。HotSpot中卡页的大小是512字节。  
一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象存在跨代指针，该卡页对应卡表的数组元素的值标识为1，称为这个元素变脏，没有则标识为0.  
在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把他们加入GC Roots中一并扫描。这样就缩减了GC Roots的扫描范围。

### 写屏障

卡表元素如何维护，何时变脏，谁来把它们变脏？   
有其他分代区域中的对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。

如果是解释执行的字节码，虚拟机负责每条字节码的执行，有充分的介入空间去更新维护卡表，但在编译执行场景中呢？  
经过即时编译后的代码已经时纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作中。

在HotSpot虚拟机里是通过写屏障（Write
Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外动作，也就是说赋值的前后都在写屏障的覆盖范围内。  
在夫之前的部分的写屏障叫做写前屏障，在赋值后的则叫做写后屏障。  
HotSpot虚拟机的许多收集器中都有使用到写前屏障，但直至G1收集器出现之前，其他收集器都只用到写后屏障。

应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对应的引用，每次只要对引用进行更新，就会产生额外的开销。  
除了写屏障的开销外，卡表在高并发场景下还面临着”伪共享“：现在中央处理器的缓存系统中是以缓存行为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能降低。  
为了避免伪共享，一个简单的解决方案时不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，已变脏的不处理。减少了写屏障的额外开销。

### 并发的可达性分析

在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象算是极少数，且在各种优化技巧的加持下，它带来的停顿已经时非常短暂且相对固定（不随堆容量而增长。）  
可从GC Roots再往下遍历对象图就必定会与Java堆容量直接成正比例关系。这时标记阶段必须的，标记阶段也是所有追踪式垃圾收集算法的共同特征。

要降低用户线程的停顿，先要搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图遍历。 三色标记把遍历对象图的过程中遇到的对象，按照”是否访问过“这个条件标记为三个颜色：

* 白色：对象尚未被垃圾收集器访问过。在可达性分析刚开始的阶段所有对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
* 黑色：对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过（和该对象直接关联的引用，可能是引用别的对象也可能是别的对象引用自己）。  
  黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
* 灰色：对象已经被垃圾收集器访问过，但这个对象至少存在一个引用还没有被扫描过。

引用是有向的，对象只有被黑色对象引用才能存活，否则，如果没有黑色对象引用它，它再如何引用其他对象都是会消亡的。   
在快照中，即此时用户线程是冻结的，只有收集器线程在工作，不会出现任何问题。

如果不是快照，用户线程和收集器并发工作，收集器在对象图上标记颜色，用户线程在修改对象引用，就可能出现

* 把原本消亡的对象错误标记为存活（影响不大，就是多了点垃圾）
* 把原本存活的对象错误标记为已消亡（程序可能发生错误）

就需要解决这个问题。加入额外的功能，具体不写了，虚拟机是通过写屏障实现的。  
在HotSpot虚拟机中，CMS是基于增量更新来做并发标记的，G1、Shenandoah是用原始快照来实现。

## 经典垃圾收集器

JDK7 Update4之后、JDK11之前，HotSpot虚拟机包含的全部可用的垃圾收集器。这些经典的收集器尽管算不上最先进的技术，但它们在实践中千锤百炼，在未来几年内能够在商用生产环境上放心使用。

* 新生代收集器：Serial、ParNew、Parallel Scavenge、G1
* 老年代收集器：CMS、Serial Old、Parallel Old、G1

收集器是需要搭配使用的。

| 老年代 ⬇ ，新生代➡|Serial|ParNew|Parallel Scavenge|G1|
|---|---|---|---|---|
|Serial Old|√|√，JDK9不可用|√，但是Serial Old有点拉跨| |
|Parallel Old| | |√，用于注重吞吐量或者处理器资源较为稀缺的场合| |
|CMS|√，JDK9不可用|√| | |
|G1| | | |√，JDK9时，取代了Parallel Scavenge+Parallel Old组合，且CMS被声明为不推荐使用| 

### Serial收集器

一个单线程收集器，基于标记-复制算法实现，迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。

### ParNew收集器

实质上是Serial收集器的多线程并行版本，在单核心处理器的环境中效果没有Serial收集器好。

### Parallel Scavenge收集器

是一款新生代收集器，基于标记-复制算法实现，也是能够并行收集的多线程收集器。  
Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值 即运行用户代码的时间/（运行用户代码的时间+运行垃圾收集时间）  
主要适合在后台运算不需要太多交互的分析任务

### Serial Old收集器

是Serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法。

### Parallel Old收集器

是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。  
在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

### CMS收集器

是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现。  
整个过程分为四个步骤

1. 初始标记：需要”Stop The World“，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
2. 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程。
3. 重新标记：需要”Stop The World“，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常比初始标记阶段稍长一些，但远比并发标记阶段的时间段。
4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活的对象，这个阶段也是可以与用户线程同时并发。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上，CMS收集器的内存回收过程是与用户线程一起并发执行的。

### Garbage First（G1）收集器

是垃圾收集器技术发展史上的里程碑式的成果，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。  
G1是一款主要面向服务端应用的垃圾收集器，JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合成为服务端模式下的默认垃圾收集器，CMS被声明为不推荐使用的收集器。

G1作为CMS收集器的替代者和继承人，设计者希望能够建立起”停顿时间模型“的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内。  
在G1收集器之前的所有收集器包括CMS，垃圾收集的目标范围要么是整个新生代，要么就是整个老年代，再要么就是整个Java堆。  
G1跳出了这个樊笼，面向堆内存任何部分来组成的回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键，G1仍然遵循分代收集理论设计，但不再坚持固定大小以及固定数量的分代区域划分，
而是把连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。  
Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过一个Region容量一般的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous
Region之中，G1的大多数行为都会把Humongous Region作为老年代的一部分看待。

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的，它们都是一系列区域的动态集合，它将Region作为单次回收的最小单元，这样可以有计划地避免再整个Java堆中进行全区域的垃圾收集，保证了G1收集器在有限的时间按内获取尽可能高的效率。

## 虚拟机及垃圾收集器日志

在JDK9之前HotSpot并没有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，日志级别，循环日志大小，输出格式，重定向等设置在不同功能上都要单独解决。  
知道JDK9，HotSpot所有功能都归到”-Xlog“参数上。

| |JDK9之前|JDK9|
|---|---|---|
|GC基本信息|-XX:+PrintGC|-Xlog:gc|
|GC详细信息|-XX:+PrintGCDetails|-Xlog:gc*|
|GC前后对、方法区可用容量变化|-XX:+PrintHeapAtGC|-Xlog:gc+heap=debug|
|GC过程中用户线程并发时间以及停顿时间|-XX:+PrintGCApplicationConcurrentTime以及-XX:+PrintGCApplicationStoppedTIme|-Xlog:safepoint|
|收集器Ergonomics|-XX:+PrintAdaptiveSizePolicy|-Xlog:gc+ergo*=trace|
|熬过收集后剩余对象的年龄分布信息|-XX:+PrintTenuringDistribution|-Xlog:gc+age=trace|

上述一些命令可以在启动Java程序的时候 放在 java命令后面测试看看，更多的就不在这里写，去书中查阅。

## 内存分配与回收策略

Java技术体系的自动内存管理，最根本的目的是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。  
对象的内存分配，从概念上讲，应该都是在堆上分配，实际上也可能经过即时编译后被拆散为标量类型并间接地在栈上分配。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下（例如对象大小超过一定阈值）也可能直接分配在老年代。

对象分配的规则并不是固定的，《Java虚拟机规范》并未规定新对象创建和存储细节，这取决于虚拟机使用的是哪一种垃圾收集器以及虚拟机中于内存相关的参数设定。

### Serial加Serial Old客户端默认收集器组合下的内存分配和回收的策略

**以下仅对Serial加Serial Old组合的收集器下的内存分配和回收策略**
一些工具命令

* jps -l：当前正在运行的虚拟机进程id和全名
* jmap -heap 进行id：生成对转储快照，有收集器名字，新生代的Eden、From、To区域和老年代内存使用情况。
* java -XX:+PrintCommandLineFlags -version：查看当前JVM的垃圾收集器（估计JDK9就不能用了）

#### 1. 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。

#### 2. 大对象直接进入老年代

大对象就是指需要大量连续内存空间的Java对象。  
尽量避免大对象，在分配空间是，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置它们，而当复制时，大对象就意味着高额的内存复制开销。  
-XX:PretenureSizeThreshold参数可以设置大于该值的对象直接在老年代分配，可以避免在Eden以及两个Survivor区之间来回复制。该参数只对Serial和ParNew这两款新生代收集器有效。

#### 3. 长期存活的对象将进入老年代

HotSpot虚拟机中多数收集器都采用了分代收集来管理内存，那内存回收时就必须能决策哪些存活对象应该当=放在新生代，哪些存活对象放在老年代中。  
为做到这点，虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过一次Minor
GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。   
对象在Survivor区中每熬过一次Minor GC，年龄就增加一岁，当它的年龄增加到一定程度（默认15），就会被晋升到老年代中。  
-XX:MaxTenuringThreshold=1 设置对象晋升到老年代的年龄阈值

#### 4. 动态对象年龄判定

HotSpot虚拟机并不是永远要求对象的年龄必须达到规定的阈值才能晋升老年代，如果在Survivor空间中有相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。

#### 5. 空间分配担保

在发生Mino GC之前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。  
如果不成立，则会先查看-XX:-HandlePromotionFailure 参数是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor
GC，尽管有风险；如果小于或者不允许 就要改为进行一次Full GC。

JDK6 Update4 忽略-XX:-HandlePromotionFailure 参数设置，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC否则进行Full GC。
