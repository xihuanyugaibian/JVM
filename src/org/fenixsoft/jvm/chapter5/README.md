## 案例分析

本章分析了一些案例，把案例中提到的一些问题提炼出来。

### 大内存硬件上的程序部署策略

* 程序设计访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象大多在分配时就直接进入老年代，没有在Minor GC中被清理掉。 会很快的消耗内存，又内存比较大，导致Full GC停顿时间过长。
* 目前单体应用在较大内存的硬件上主要的部署方式有两种
  1. 通过一个单独的Java虚拟机实例来管理大量的Java内存。
  2. 同时使用若干个Java虚拟机，监理逻辑集群来利用硬件资源。
* 对于用户交互性强，对停顿时间敏感，内存又较大的系统，并不一定要使用Shenandoah、ZGC这些明确以控制延迟为目标的垃圾收集器才能解决问题（情况允许还是优先考虑）， 使用Parallel Scavenge/Old
  收集器，并且给Java虚拟机分配较大的堆内存也行，但是必须把应用的Full GC频率控制的足够低，至少要低到不会在用户使用过程中发生，譬如一整天都不出现一次Full GC，这样可以固定时间主动触发Full GC。
* 在许多网站和B/S形式的应用里，多数对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对较少。通过合理的代码编写就可以减少Full GC。
* 同时使用若干个虚拟机建立逻辑集群来利用硬件资源。做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。

### 堆外内存导致的溢出错误

* 操作系统对每个进程能管理的内存是有限制的。32位Windows平台的限制是2GB，如果划分给Java堆1.6G，而Direct Memory耗用的内存并不算入堆内，因此它最大只能在剩余的0.4G中占用一部分。
* 垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足就主动通知收集器进行垃圾回收，它只能等老年代满后Full GC出现，顺便进行。
  否则只能等到抛出内存溢出异常时，捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集
* <u>在处理小内存或者32位的应用问题时，除了Java堆和方法区之外，还有一下区域会占用较多内存，并且这些内存总和受到操作系统进程最大内存的限制。
  * 直接内存：可通过-XX:MaxDirectMemorySize调整大小。
  * 线程堆栈：可通过-Xss调整大小。
  * Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，分别占大约37KB和25KB，连接多的话也会占用较多内存。
  * JNI代码：如果使用JNI调用本地库，本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存。
  * 虚拟机和垃圾收集器：工作时消耗一定量的内存。</u>

### 外部命令导致系统缓慢

* 通常情况下用户应用的处理器占用率应该占主要地位，才能说明系统实在正常工作。
* 在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生。
* Java的Runtime.getRuntime().exec()
  可以达到执行shell脚本的目的，但是在Java虚拟机中是非常消耗资源。Java虚拟机执行这个命令的过程是首先复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再推出这个进程。

### 不恰当的数据结构导致内存占用过大

> 在HashMap<Long,Long>结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16字节。  
> 这两个长整型数据包装成java.lang.Long对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节的存储数据的long值。  
> 然后这2个Long对象组成Map.Entry之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充。  
> 实际耗费内存为(Long(24byte)*2)+Entry(32byte)+HashMap Ref(8byte)=88byte。空间效率为有效数据除以全部内存空间即 16/88=18%。

### 由Windows虚拟内存导致的长时间停顿

Java的GUI程序在最小化时它的工作内存被自动交换到磁盘的页面文件中，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。  
可通过-Dsun.awt.keepWorkingSetOnMinimize=true来解决。

### 由安全点导致长时间停顿

* -XX:MaxGCPauseMillis参数设置到500，打印垃圾收集停顿在500毫秒以上的日志。
* 处理器时间代表线程占用处理器一个核心的耗时计数，时钟时间就是现实世界中的时间计数。
  * user:进程执行用户态代码耗费的处理器时间。
  * sys:进程执行核心态代码耗费的处理器时间。
  * real:执行动作从开始到结束耗费的始终时间。
* -XX:+PrintSafepointStatistics和-XX:PrintSafepointStatisticsCount=1 去查看安全点日志，日志显示当前虚拟机的操作所有用户线程进入到安全点等待的时间。
* -XX:+SafepointTimeout和-XX:SafepointTimeoutDelay=2000两个参数，让虚拟机在等待线程进入安全点时间超过2000毫秒时就认定为超时，这样就会输出导致问题的线程名称。
* <u>安全点是以“是否具有让线程长时间执行的特征”为原则进行选定，所以方法的调用，循环跳转，异常跳转这些位置都可能会设置安全点，
  但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间也不会太长，所以使用int类型或者范围更小的数据类型作为索引值的循环默认是不会设置安全点的。
  <br>通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环单次执行就特别慢，也可能会耗费很多的时间。</u>
