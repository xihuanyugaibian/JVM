## 后端编译与优化

### 即时编译器

#### 解释器与编译器

当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。  
当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间消耗，获得更高的执行效率。

HotSpot虚拟机中内置3个即时编译器：两个存在已久：客户端编译器、服务端编译器，第三个JDK10才出现Graal还处于实现状态。  
在分层编译的工作模式出现以前，HotSpot虚拟机采用解释器和其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，
HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用参数强制指定虚拟机运行在客户端模式还是服务端模式。

* 混合模式：无论采用的编译器是客户端还是服务端，解释器与编译器搭配使用的方式。
* 解释模式：编译器完全不介入工作，全部代码都使用解释方式执行。
* 编译模式：优先使用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。

为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。根据编译器编译、优化的规模与耗时，划分出不同的编译层次  
第0层：程序纯解释执行，并且解释器不开启性能监控。   
第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启了监控性能。  
第2层：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。  
第3层：仍然使用客户端编译器执行，开启全部性能监控和统计信息。  
第4层：使用服务端编译器将字节码编译为本地代码，还会根据性能监控信息进行一些不可靠的激进优化。  
以上层次并不是固定不变的，虚拟机可以调整分层的数量，实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，
热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，
在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。

#### 编译对象与触发条件

热点代码

* 被多次调用的方法
* 被多次执行的循环体

编译的目标对象都是整个方法体，而不会是单独的循环体。  
情况1是虚拟机中标准的即时编译方式  
情况2只是执行入口稍有不同，因为编译发生在方法执行的过程中，被称为“栈上替换”：方法的栈帧还在栈上，方法就被替换了。

要知道某段代码是不是热点代码，是不是需要触发即时编译的行为称为“热点探测”

* 基于采样的热点探测：虚拟机周期性检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶，这个方法就是热点方法。实现简单高效，很难精准确定一个方法的热度，容易受到线程阻塞或别的外界因素影响。
* 基于计数器的热点探测：虚拟机会为每个方法建立计数器，统计方法的执行次数，超过一定阈值就认为它是热点代码。实现麻烦，统计结果更加精确严谨。
    * 方法调用计数器：用于统计方法被调用的次数。默认设置统计的是执行频率，有半衰周期。
    * 回边计数器：统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为回边。

#### 编译过程

在默认条件下，无论是方法调用产生的标准编译请求耗时栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。  
用户可以通过参数禁止后台编译，禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。

客户端编译器  
第一个阶段 字节码——》方法内联、常量传播等——》HIR  
第二个阶段 HIR——》空值检查消除、范围检查消除——》LIR  
最后阶段：LIR——》寄存器分配、窥孔优化、机器码生成——》本地代码

服务端编译：是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个容忍高优化复杂度的高级编译器。

### 提前编译器

提前编译有两个方向

1. 与传统C、C++编译器类似，在程序运行之前把程序代码编译成机器码的静态翻译工作。
2. 把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码是直接把它加载进来使用。

### 编译器优化技术

编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实难点并不在能不能翻译出机器代码，输出代码优化质量的高低才是决定编译器是否优秀的关键。

* 方法内联：把目标的方法的代码原封不动的复制到发起调用的方法之中，避免发生真实的方法调用。
* 逃逸分析：分析对象的动态作用域，当一个对象在方法里面被定义以后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种为方法逃逸；甚至被外部线程访问到称为线程逃逸；
    * 栈上分配：如果一个对象不会逃逸出线程之外，让这个对象在栈上分配内存，对象所占用的空间就可以随栈帧出栈而销毁。
    * 标量替换：把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就是标量替换。标量替换可以视为栈上分配的一种特例，对逃逸程度要求更高，不允许对象逃逸出方法范围。
    * 同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，这个变量的读写肯定不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。
* 公共子表达式消除：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对这种表达式，没有必要花时间重新计算，只需要直接用前面计算过的表达式结果代替E。
* 数组边界检查消除：在Java语音中访问数组元素的时候系统将会自动进行上下界的范围检查，及foo\[i\]的i须满足`i>=0&&i<foo.length`。
  这对软件开发者来说是一件友好的事情，对于虚拟机的执行子系统，每次数组元素的读写都带有一次隐含的条件判断，必定是一种负担。在编译器能确定i没有越界，执行时就无须判断了。
