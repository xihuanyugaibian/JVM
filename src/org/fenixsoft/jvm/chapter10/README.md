## 前端编译与优化

前端编译器：把.java文件转变为.class文件。JDK的Javac等。  
即时编译器：运行期把字节码转变为本地机器码。HostSpot虚拟机的C1、C2编译器等。  
提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码的过程。JDk的Jaotc等。

前端编译器Javac做了许多针对Java语言编码过程的优化措施来降低程序员的编码复杂度，提高编码效率。  
Java中即时编译器在运行期的优化过程支撑了程序执行效率的不断提升，而前端编译器在编译器的优化过程则支撑了程序员的编码效率和语言使用者的幸福感的提升。

### Javac编译器

#### Javac的源码与调试

JDK8中实现代码在JDK目录下的lib包下的tools.jar中的com.sun.tools.javac。  
可以运行com.sun.tools.javac.Main.main方法来执行编译，可以使用的参数与使用命令行中的javac命令一致。

从Javac带的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程。

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程。  
   词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树  
   填充符号表：产生符号地址和符号信息
3. 插入式注解处理器的注解处理过程。
4. 分析与字节码生成过程。  
   标注检查：对语法的静态信息进行检查。  
   数据流及控制流分析：对程序动态运行过程进行检查。    
   解语法糖：将简化代码编写的语法糖还原为原有的格式。  
   字节码生成：将前面各个步骤所生成的信息转化为字节码。

其中234这三个处理过程中3又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的2中重新处理这些新符号。

Javac的编译动作的代码在 com.sun.tools.javac.main.JavaCompiler.compile()方法中。

```java
initProcessAnnotations(processors); //1.准备过程：初始化插入式注解处理器

// These method calls must be chained to avoid memory leaks
delegateCompiler =
    processAnnotations( //3.插入式注解处理器的注解处理过程
        enterTrees(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects))), //2.2 enterTrees 填充符号表; 2.1 parseFiles 词法、语法分析
        classnames);
delegateCompiler.compile2();  //4.分析与字节码生成过程。

//compile2()中的
case BY_TODO:
    while (!todo.isEmpty())
        generate(desugar(flow(attribute(todo.remove()))));  //4.4 generate字节码生成；4.3 desugar解语法糖；4.2 flow数据流及控制流分析；4.1 attribute标注检查
    break;
```

#### 解析与填充符号表

词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记。  
语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree)是一种用来描述程序代码语法结构的树形表示方式，它的每一个节点都代表着程序中的一个语法结构。  
经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程。  
符号表是一组符号地址和符号信息构成的数据结构，符号表中所登记的信息在编译的不同阶段都要被用到。该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点以及package-info.java的顶级节点。

#### 注解处理器

把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树炸的任意元素。  
如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解没有再对语法树进行修改为止，每一次循环过程称为一个轮次(Round).

#### 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。  
而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查。

1. 标注检查  
   标注检查要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等等。在标注检查中，还会顺便进行一个称为常量折叠的代码优化。
2. 数据及控制流分析  
   它可以检查出诸如程序局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。  
   编译时期的数据及控制流分析与类加载时的数据及控制流分析目的上基本一致，区别是校验范围不同。
   把局部变量声明为final对运行期是完全没有影响的，变量的不变性仅仅由Javac编译器在编译期间来保障，这就是一个只能在编译期而不能在运行期检查的例子。
3. 解语法糖  
   Java中最常见的语法糖有泛型、变长参数、自动装箱拆箱等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程称为解语法糖。
4. 字节码生成  
   字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化为字节码指令写到磁盘，编译期还进行了少量的代码添加和转换工作。  
   例如实例构造器\<init\>()方法和类构造器\<clinit\>()方法就是在这个阶段被添加到语法树之中的。
   这里的实例构造器并不等同于默认构造器，如果用户代码中没有提供任何构造函数，那编译期会添加一个没有参数、可访问性与当前类型一致的默认构造函数，这个工作在填充符号表阶段完成的。  
   \<init\>()和\<clinit\>()的产生实际上是一种代码收敛的过程，编译期会把语句块、变量初始化、调用父类的实例构造器等操作收敛到\<init\>()和\<clinit\>()方法之中，并且无论源码中出现的顺序如何，
   都一定是按**先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行**。  
   例如把字符串的加操作符替换为StringBuild的append()操作等等。

### Java语法糖的味道

#### 泛型

#### 自动装箱、拆箱与遍历循环

#### 条件编译

许多程序语言都提供了条件编译的途径，C、C++中使用预处理器指示符来完成条件编译。C、C++预处理器最初的任务是解决编译时的代码依赖关系。
而在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式(编译期并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息)就无须使用到预处理器。

Java语言也可以进行条件编译，方法就是使用条件为常量的if语句。
