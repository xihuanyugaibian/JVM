## 前端编译与优化

前端编译器：把.java文件转变为.class文件。JDK的Javac等。  
即时编译器：运行期把字节码转变为本地机器码。HostSpot虚拟机的C1、C2编译器等。  
提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码的过程。JDk的Jaotc等。

前端编译器Javac做了许多针对Java语言编码过程的优化措施来降低程序员的编码复杂度，提高编码效率。  
Java中即时编译器在运行期的优化过程支撑了程序执行效率的不断提升，而前端编译器在编译器的优化过程则支撑了程序员的编码效率和语言使用者的幸福感的提升。

### Javac编译器

#### Javac的源码与调试

JDK8中实现代码在JDK目录下的lib包下的tools.jar中的com.sun.tools.javac。  
可以运行com.sun.tools.javac.Main.main方法来执行编译，可以使用的参数与使用命令行中的javac命令一致。

从Javac带的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程。

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程。  
   词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树  
   填充符号表：产生符号地址和符号信息
3. 插入式注解处理器的注解处理过程。
4. 分析与字节码生成过程。  
   标注检查：对语法的静态信息进行检查。  
   数据流及控制流分析：对程序动态运行过程进行检查。    
   解语法糖：将简化代码编写的语法糖还原为原有的格式。  
   字节码生成：将前面各个步骤所生成的信息转化为字节码。

其中234这三个处理过程中3又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的2中重新处理这些新符号。

Javac的编译动作的代码在 com.sun.tools.javac.main.JavaCompiler.compile()方法中。

```java
initProcessAnnotations(processors); //1.准备过程：初始化插入式注解处理器

// These method calls must be chained to avoid memory leaks
delegateCompiler =
    processAnnotations( //3.插入式注解处理器的注解处理过程
        enterTrees(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects))), //2.2 enterTrees 填充符号表; 2.1 parseFiles 词法、语法分析
        classnames);
delegateCompiler.compile2();  //4.分析与字节码生成过程。

//compile2()中的
case BY_TODO:
    while (!todo.isEmpty())
        generate(desugar(flow(attribute(todo.remove()))));  //4.4 generate字节码生成；4.3 desugar解语法糖；4.2 flow数据流及控制流分析；4.1 attribute标注检查
    break;
```

#### 解析与填充符号表

词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记。  
语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree)是一种用来描述程序代码语法结构的树形表示方式，它的每一个节点都代表着程序中的一个语法结构。  
经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程。  
符号表是一组符号地址和符号信息构成的数据结构，符号表中所登记的信息在编译的不同阶段都要被用到。该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点以及package-info.java的顶级节点。

#### 注解处理器

把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树炸的任意元素。  
如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解没有再对语法树进行修改为止，每一次循环过程称为一个轮次(Round).

#### 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。  
而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查。

1. 标注检查  
   标注检查要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等等。在标注检查中，还会顺便进行一个称为常量折叠的代码优化。
2. 数据及控制流分析  
   它可以检查出诸如程序局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。  
   编译时期的数据及控制流分析与类加载时的数据及控制流分析目的上基本一致，区别是校验范围不同。
   把局部变量声明为final对运行期是完全没有影响的，变量的不变性仅仅由Javac编译器在编译期间来保障，这就是一个只能在编译期而不能在运行期检查的例子。
3. 解语法糖  
   Java中最常见的语法糖有泛型、变长参数、自动装箱拆箱等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程称为解语法糖。
4. 字节码生成  
   字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化为字节码指令写到磁盘，编译期还进行了少量的代码添加和转换工作。  
   例如实例构造器\<init\>()方法和类构造器\<clinit\>()方法就是在这个阶段被添加到语法树之中的。
   这里的实例构造器并不等同于默认构造器，如果用户代码中没有提供任何构造函数，那编译期会添加一个没有参数、可访问性与当前类型一致的默认构造函数，这个工作在填充符号表阶段完成的。  
   \<init\>()和\<clinit\>()的产生实际上是一种代码收敛的过程，编译期会把语句块、变量初始化、调用父类的实例构造器等操作收敛到\<init\>()和\<clinit\>()方法之中，并且无论源码中出现的顺序如何，
   都一定是按**先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行**。  
   例如把字符串的加操作符替换为StringBuild的append()操作等等。

### Java语法糖的味道

#### 泛型

泛型的本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。  
泛型让程序云能够针对泛化的数据类型编写相同的算法，这极大增强了编程语言的类型系统及抽象能力。

Java选择的泛型实现方式是：类型擦除式泛型。只在程序源码中可见，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型，并且在相应的地方插入了强制类型转换，因此对运行期的Java语言来说，ArrayList(Integer)与ArrayList(Sting)其实是同一个类型。  
C#选择的泛型实现方式是：具显化式泛型。无论在程序源码里面、编译后的中间语言表示里面、亦或是运行期的CLR里面都是切实存在的，List(int)与List(String)就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。

Java的类型擦除式泛型无论在效果上还是运行效率上，几乎是全面落后于C#的具显化式泛型，而它的唯一优势是在于实现这种泛型的影响范围上：  
擦除式泛型的实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java5.0上。

为了保证之前编译出来的Class文件可以在引入反省后继续运行，设计者有两条路选择

1. 需要泛型化的类型，以前有的保持不变，然后平行地增加一套泛型化版本的新类型。
2. 直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。

C#就是选择的1，因为Java问世时间久，遗留代码的规模不在一个数量级，并且在JDK1.2时Java引入过ArrayList,HashMap等集合，再增加一套泛型的集合代码比较冗余就选的2.

**那么要让所有需要泛型化的已有类型，譬如ArrayList，原地泛型化后变为ArrayList\<T\>，而且还要保证以前直接用ArrayList的代码在泛型版本还能继续使用，  
这就必须让所有泛型化的实例类型，譬如 ArrayList(Integer)、ArrayList(Sting)这些全部自动成为Arraylist的子类型才行，否则类型转换就是不安全的。**  
由此引出裸类型：裸类型应被视为所有该类型的泛型化实例的共同父类型。ArrayList就是裸类型，ArrayList(Integer)与ArrayList(Sting)是ArrayList的泛型化实例。

我理解的擦除就是 在编译时把ArrayList(Integer)还原为ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令。

```java
 public static void main(String[] args) {
     Map<String, String> map = new HashMap<>();
     map.put("1", "1");
     System.out.println(map.get("1"));
 }
//编译后，反编译的
public static void main(String[] args) {
  Map<String, String> map = new HashMap();
  map.put("1", "1");
  System.out.println((String)map.get("1"));//多了一个强制类型转换
}
```

擦除法 仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。

#### 自动装箱、拆箱与遍历循环

包装类的"=="运算在不遇到算术运算的情况下不会自动拆箱，且它们的equals()方法不处理数据转型关系。

#### 条件编译

许多程序语言都提供了条件编译的途径，C、C++中使用预处理器指示符来完成条件编译。C、C++预处理器最初的任务是解决编译时的代码依赖关系。
而在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式(编译期并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息)就无须使用到预处理器。

Java语言也可以进行条件编译，就是使用条件为常量的if语句。也只有这一种。如果使用常量与其他带有条件判断能力的语句则不行。  
如下 编译后方法中只有 System.out.println(true);

```java
 public static void main(String[] args) {
     if (true) {
         System.out.println(true);
     } else {
         System.out.println(false);
     }
 }
```
