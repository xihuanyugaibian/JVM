## 类文件结构

### 无关性的基石

各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码 是构成<u>平台无关性</u>的基石。  
虚拟机也有另外一种中立特性——<u>语言无关性</u>。实现语言无关性的基础仍然是虚拟机和字节码存储格式。 Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。  
Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。 因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。

### Class类文件的结构

任何一个Class文件都对应着唯一的一个类或接口定义的信息，但是反过来说，类或接口并不一定都得定义在文件里（也可以动态生成）  
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地列在文件中，中间没有添加任何分隔符。当遇到需要占用8位以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

根据《Java虚拟机规范》，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表

* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分以 ”_info“结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视为一张表。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。参考下表中的constant_pool_count

| 类型             | 名称                  | 数量                    | 说明                                                                                                                                               |  
|----------------|---------------------|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------| 
| u4             | magic               | 1                     | 每个Class文件的头4个字节被称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。值为OxCAFFBABE。                                                                             |
| u2             | minor_version       | 1                     | 次版本号，从JDK1.2到JDK12之前均未再使用，全部固定为0.到了JDK12，由于JDK提供的功能已经非常庞大，有一些复杂的新特性需要以公测的形式放出，被设计者重新启用，用于标识技术预览版功能特性的支持。                                         |
| u2             | major_version       | 1                     | 主版本号，Java的版本号是从45开始的，JDK1.1以后每个大版本发布，主版本号+1.高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。                                                          |
| u2             | constant_pool_count | 1                     | 常量池容量计数值，代表常量池中有 <u>计数值-1</u> 项常量,设计者将第0型常量空出来，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。                                      |
| cp_info        | **constant_pool**   | constant_pool_count-1 | 常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，还是Class文件中第一个出现的表类型数据项目。常量池中每一项常量都是一个表，表结构起始的第一位是个u1类型的标志位，代表当前常量属于哪种类型。 |
| u2             | access_flags        | 1                     | 访问标志用于识别一些类或者接口层次的访问信息。这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否声明未final等。                                                           |
| u2             | this_class          | 1                     | 类索引用于确定这个类的全限定名                                                                                                                                  |
| u2             | super_class         | 1                     | 父类索引用于确定这个类的父类的全限定名                                                                                                                              |
| u2             | interfaces_count    | 1                     | 接口计数器表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口索引表不再占用任何字节。                                                                                             |
| u2             | interfaces          | interfaces_count      |                                                                                                                                                  |
| u2             | fields_count        | 1                     | 容量计数器说明这个类有多少个字段表数据。                                                                                                                             |
| field_info     | **fields**          | fields_count          | 字段表用于描述接口或者类中声明的变量。Java语言中的字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。                                                                                      |
| u2             | methods_count       | 1                     | 容量计数器代表集合中有多少个方法。                                                                                                                                |
| method_info    | **methods**         | methods_count         | Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式。                                                                                                           |
| u2             | attributes_count    | 1                     | 容量计数器代表集合中有多少个属性                                                                                                                                 |
| attribute_info | **attributes**      | attributes_count      | Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息                                                                                                        |

#### 常量池

常量池中的常量的数量是不固定的，在常量池的入口需要放置一项u2类型的数据 constant_pool_count，代表常量容量计数值。  
常量池中主要存放两大类常量：字面量和符号引用

* 字面量比较接近Java语言层面的常量概念，入文本字符串、被声明为final的常量值等。
* 符号引用属于编译原理方面的概念，主要包括以下几类常量
    1. 被模块导出或者开放的包
    2. 类和接口的全限定名
    3. 字段的名称和描述符
    4. 方法的名称和描述符
    5. 方法句柄和方法类型
    6. 动态调用点和动态常量

Java代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。即 在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些方法、字段的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用。   
<u>当虚拟机做类加载时，将会从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。</u>

常量池中的每一项都是一个表，最初共有11种结构各不相同的表结构数据，截至到JDK13增加到17种不同类型的常量，他们都有一个共同的特点，表结构的第一位是个u1类型的标志位，代表当前常量属于哪种常量类型。 除此之外 17种常量类型各自有着完全独立的数据结构，两两之间并没有什么共性和联系。

这里只记录一下 CONSTANT_Utf8_info 型常量结构，其他的什么标志位对应什么类型的常量，什么类型的常量表结构如何不再细写，需要再去网络或者翻书查询。

| 类型 | 名称     | 数量     | 说明                                                              |
|----|--------|--------|-----------------------------------------------------------------|
| u1 | tag    | 1      | 标志位用于区分常量类型，CONSTANT_Utf8_info型常量值为1                            |
| u2 | length | 1      | 这个UTF-8编码的字符串长度是多少个字节，它后面紧跟着长度为length字节的连续数据是一个使用UTF-8缩略码表示的字符串 |
| u1 | bytes  | length | 使用UTF-8缩略码表示的长度为length字节的字符串                                    |

> 由于CLass文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度=length的最大值=u2类型能表达的最大值65535.
> 所以Java程序中如果定义了超过64KB英文字符的变量或则和方法名，即使规则和全部字符都是合法的，也会无法编译。

**javap -verbose Class文件名：Java自带的专门用于分析Class文件字节码的工具。**

#### 访问标志

在常量池结束之后，紧接着的2个字节代表访问标志，用于标识一些类或者接口层次的访问信息，包括：这个CLass是类还是接口、是否定义位public类型、是否定义位abstract类型、如果是类的话，是否被声明为final。

#### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项数据确定该类型的继承关系。  
类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口，按implements关键字后的接口顺序从左到右排列在接口索引集合中。  
接口索引集合，人口的第一项u2类型的数据为接口计数器，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。

#### 字段表集合

| 类型              | 名称               | 数量               | 说明                                                      |
|-----------------|------------------|------------------|---------------------------------------------------------|
| u2              | access_flags     | 1                | 修饰符：作用域、static、final、volatile、transient、enum、是否由编译器自动产生 |
| u2              | name_index       | 1                | 简单名称：没有类型和参数修饰的方法或者字段名称                                 |
| u2              | descriptor_index | 1                | 描述符：用来描述字段的数据类型、方法的参数列表（数量、类型和顺序）和返回值。                  |
| u2              | attributes_count | 1                | 属性表计数器                                                  |
| attributes_info | attributes       | attributes_count | 属性表集合用于存储一些额外的信息                                        |

字段表用于描述接口或者类中声明的变量。Java语言中的字段包括类级变量以及实例级变量，但不包括局部变量。  
字段可以包括的修饰符有字段的作用域（private、protected、public）、是实例变量还是类变量（static）、可变性（final）、并发可行性（volatile）、可否被序列化（transient）、数据类型（基本类型、对象、数组）、名称。    
描述符规则：基本数据类型以及代表无返回值的void类型都用一个大写字符表示，对象类型用字符L加对象的全限定名来表示，对于数组类型，每一维度使用一个前置的[来描述 例如java.lang.String[]被记录为`[Ljava/lang/String;`int[][]被记录为`[[I`  
描述符用来描述方法时，按照先参数列表，后返回值的顺序，参数列表按照参数的严格顺序放在()之内,例如 void test()的描述符为`()V` int indexOf(char[])描述符为`([C)I`  
字段表集合中不会列出从父类或者父接口中继承而来的字段，但是有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。
在Java语言中字段是无法重载的，两个字段的数据类型修饰符不管是否相同，都必须使用不一样的名称，但是对于CLass文件格式来讲，只要两个字段的描述符不是完全相同，那字段就是合法的，即这里Java语言比Class文件要求严格。

#### 方法表集合

| 类型             | 名称               | 数量               | 说明                                                                                           |
|----------------|------------------|------------------|----------------------------------------------------------------------------------------------|
| u2             | access_flags     | 1                | 修饰符：作用域、static、final、synchronized、是否由编译器产生的桥接方法、是否接收不定参数、native、abstract、strictfp、是否由编译器自动产生 |
| u2             | name_index       | 1                | 简单名称：没有类型和参数修饰的方法或者字段名称                                                                      |
| u2             | descriptor_index | 1                | 描述符：用来描述字段的数据类型、方法的参数列表（数量、类型和顺序）和返回值。                                                       |
| u2             | attributes_count | 1                | 属性表计数器                                                                                       |
| attribute_info | attributes       | attributes_count | 属性表集合用于存储一些额外的信息                                                                             |

方法里的Java代码，经过javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为Code的属性里面。  
方法表中如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但有可能会出现编译器自动添加的方法，最常见的便是类构造器<clinit>()方法和实例构造器<init>()方法。

在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要必须拥有一个与原方法不同的特征签名。  
特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大，只要描述符不是完全一致的两个方法就可以共存。  
Java代码的方法的特征签名只包括方法名称、参数顺序、参数类型，字节码的特征签名还包括方法返回值和受查异常表。

#### 属性表集合

| 类型 | 名称                   | 数量                 | 说明                                                   |
|----|----------------------|--------------------|------------------------------------------------------|
| u2 | attribute_name_index | 1                  | 一项指向CONSTANT_Utf8_info型常量的索引，它代表该属性的属性名称             |
| u4 | attribute_length     | 1                  | 属性表的长度                                               |
| u1 | info                 | attribute_length-6 | 属性值：由于属性名称索引与属性长度占用6个字节，所以属性值长度固定为attribute_length-6 |

Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。且属性表集合的限制稍微宽松一些，不再要求每个属性表具有严格顺序。  
对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值占用的位数即可。  
为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机都应当能识别的属性，截至到JavaSE 12版本，预定义属性已经增加到29项，具体需要时在查询，这里不展开。只介绍一个Code属性。

| 类型             | 名称                     | 数量                     | 说明                                                              |
|----------------|------------------------|------------------------|-----------------------------------------------------------------|
| u2             | attribute_name_index   | 1                      | 一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为Code，它代表该属性的属性名称            |
| u4             | attribute_length       | 1                      | 属性表的长度                                                          |
| u2             | max_stack              | 1                      | 操作数栈深度的最大值，在方法执行的任意时候，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度 |
| u2             | max_locals             | 1                      | 局部变量表所需的存储空间，单位是变量槽（虚拟机为局部变量分配内存所使用的最小单位）                       |
| u4             | code_length            | 1                      | 字节码长度                                                           |
| u1             | code                   | code_length            | 存储字节码指令的一系列字节流                                                  |
| u2             | exception_table_length | 1                      |                                                                 |
| exception_info | exception_table        | exception_table_length | 显式异常处理表集合，有自己单独的接口，不必深究                                         |
| u2             | attributes_count       | 1                      |                                                                 |
| attribute_info | attributes             | attributes_count       | 属性表集合：不必深究                                                      |

* max_locals：并不是在方法中用了多少个局部变量就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。  
  Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超过一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。
* code_length和code用来存储Java源程序编译后生成的字节码指令，每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后买你是否需要跟随参数。  
  一个u1数据类型一共可以表达256条指令，目前《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义。
    * code_length虽然是一个u4类型的长度值，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，javac编译器就会拒绝编译。
    * code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（方法体里面的Java代码）和<u>元数据（类、字段、方法定义及其他信息）两部分</u>，那么在整个Class文件里Code属性用于描述代码，所有的其他数据项目都用于描述元数据。
* 在任何实例方法里面，都可以通过this关键字访问此方法所属的对象。<u>这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。</u>  
  因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。

### 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表者某种特定操含义的数字（操作码）以及跟随气候的零至多个代表此操作所需的参数（操作数）构成。由于Java虚拟机采用面向操作数栈而不是面向寄存器的结构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

由于限制了Java虚拟机操作码的长度为一个字节，即指令集的操作码总数不超过256条，又Class文件格式放弃了编译后代码的操作数长度对齐，意味着虚拟机在处理超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构。  
这种操作在某种程度上导致解释执行字节码时将损失一些性能，优势也很明显 放弃了操作数长度对齐，可以省略掉大量的填充和间隔符号；用一个字节来代表操作码，尽可能获得短小精干的编译代码。

#### 字节码与数据类型

在Java虚拟机的指令集中，大多数指令都包含其操作数所对应的数据类型信息。  
对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。  
Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集会被故意设计称非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。  
大多数对于boolean、byte、short、char类型数据的操作，实际都是使用对应的对int类型作为运行类型来进行的。

#### 加载和存储指令

用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。

#### 运算指令

用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作数栈顶。

#### 类型转换指令

将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作，或者用于处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

#### 对象创建和访问指令

类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。

#### 操作数栈管理指令

#### 控制转移指令

#### 方法调用和返回指令

#### 异常处理指令

#### 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程来实现的。  
方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中synchronized得知一个方法是否被声明为同步方法。
<u>当方法调用时，调用指令将会检查是否为同步方法，是则执行线程就要求先成功持有管程然后才能执行方法，当方法完成时释放管程。在方法执行期间，执行线程持有管程，其他任何线程都无法再获取到同一个管程。
如果一个同步方法执行期间抛出了异常，并在在方法内部无法处理异常，这个同步方法所持有的管程将会在异常抛到同步方法边界之外时自动释放。

同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中由monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要javac编译器与Java虚拟机两者共同协作支持。  
编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter都必须有对应的monitorexit指令，无论该方法是正常结束还是异常结束。</u>
