## 虚拟机字节码执行引擎

执行引擎是Java虚拟机核心的组成部分之一。  
”虚拟机“是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，
而虚拟机的执行引擎是由软件实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，栈帧则是支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
每一个方法从调用开始至执行结束的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、操作数栈、动态连接和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入方法表的Code属性中。

一个线程中的方法调用链可能会很长，以Java的角度来看，同一时刻，同一条线程里面，在调用堆栈的所有方法都是同时处于执行状态。  
而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。  
执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。

#### 局部变量表

是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
在Java程序被编译为Class文件的时候，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。  
局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据。
这八种数据类型都可以使用32位或更小的物理内存来存储，但这种描述与明确指出“每个变量槽应占用32位长度的内存空间”有本质差别，**它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化**，
保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。**如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用**，在方法中可以通过关键字this来访问这个隐含的参数。  
其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

局部变量表中的变量槽是可以重复使用的方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码的PC计数器的值已经超过了某个变量的作用域，该变量对应的变量槽就可以交给其他变量来重用。
（有时候虽然出了变量的作用域以后触发垃圾回收，变量如果没有被重用可能还在变量槽中，该变量指向的实例也是不会被回收的。局部变量表属于GC Root）

#### 操作数栈

操作数栈的最大深度在编译时被写入到Code属性的max_stacks数据项中，操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位占栈容量1，64位占2。  
当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈。  
操作数栈中元素的数据类型与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要在验证一次。  
在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全独立的。但在大多数虚拟机的实现里都会进行一些优化，令两个栈帧出现一部分重叠。
让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，不仅节约了一些空间，更是在进行方法调用的时可以直接共用一部分数据，无须进行额外的参数赋值传递。

