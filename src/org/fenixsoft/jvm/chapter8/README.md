## 虚拟机字节码执行引擎

执行引擎是Java虚拟机核心的组成部分之一。  
”虚拟机“是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，
而虚拟机的执行引擎是由软件实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，栈帧则是支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
每一个方法从调用开始至执行结束的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、操作数栈、动态连接和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入方法表的Code属性中。

一个线程中的方法调用链可能会很长，以Java的角度来看，同一时刻，同一条线程里面，在调用堆栈的所有方法都是同时处于执行状态。  
而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。  
执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。

#### 局部变量表

是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
在Java程序被编译为Class文件的时候，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。  
局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据。
这八种数据类型都可以使用32位或更小的物理内存来存储，但这种描述与明确指出“每个变量槽应占用32位长度的内存空间”有本质差别，**它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化**，
保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。**如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用**，在方法中可以通过关键字this来访问这个隐含的参数。  
其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

局部变量表中的变量槽是可以重复使用的方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码的PC计数器的值已经超过了某个变量的作用域，该变量对应的变量槽就可以交给其他变量来重用。
（有时候虽然出了变量的作用域以后触发垃圾回收，变量如果没有被重用可能还在变量槽中，该变量指向的实例也是不会被回收的。局部变量表属于GC Root）

#### 操作数栈

操作数栈的最大深度在编译时被写入到Code属性的max_stacks数据项中，操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位占栈容量1，64位占2。  
当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈。  
操作数栈中元素的数据类型与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要在验证一次。  
在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全独立的。但在大多数虚拟机的实现里都会进行一些优化，令两个栈帧出现一部分重叠。
让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，不仅节约了一些空间，更是在进行方法调用的时可以直接共用一部分数据，无须进行额外的参数赋值传递。

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。  
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。  
这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。  
另一部分将在每一次运行期间都转化为直接引用，这部分称为**动态连接**。

#### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法。

1. 正常调用完成：执行引擎遇到任意一个方法返回的字节码指令，此时可能会有返回值传递给上层的方法调用者，方法是否有返回此以及返回值的类型将根据遇到的返回指令来决定。
2. 异常调用完成：在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常还是代码使用字节码指令产生的异常，只要在本地方法异常表中没有搜索到匹配的处理器，就会导致方法的退出。  
   不会给它的上层调用者提供返回值。

无论何种退出方式，在方法退出后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法方法返回时可能需要在栈帧中赵存一些信息，用来帮助恢复它的上层方法调用者的执行状态。

#### 附加信息

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有的描述信息到栈帧中，例如与调试，性能收集相关的信息。  
在讨论概念时，一般会把动态连接，方法返回地址与其他附加信息统称为栈帧信息。

### 方法调用

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法的具体运行过程。  
Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。  
这个特性给Java带来了更强大的动态扩展能力，但也使Java方法的调用过程更复杂，某些调用需要在类加载期间，甚至到运行时才能确定目标方法的直接引用。

#### 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在列加载解析阶段，会将一部分符号引用转化为直接引用，这部分需要满足：  
方法在程序运行之前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可变的。即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析。

在Java语言中符合”编译器可知，运行期不可变“的方法主要有：静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特性决定了它们都不可能通过继承或别的方式被重写。

调用不同类型的方法，字节码指令集里设计了不同的指令。

* invokestatic:调用静态方法
* invokespecial:调用实例构造器<init>()方法，私有方法和父类中的方法。
* invokevirtual:调用所有的虚方法
* invokeinterface:调用接口方法，会在运行时在确定一个实现该接口的对象。
* invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。其他四条指令的分派逻辑固化在虚拟机内部。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合的有静态方法、私有方法、实例构造器、父类方法四种，
再加上被final修饰的方法（即使它使用invokevirtual指令调用），**这五种方法调用时会在类加载的时候就可以把符号引用解析为该方法的直接引用。 这些方法统称为”非虚方法“，与之相反其他方法被称为”虚方法“**。

**解析调用一定是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。**  
另一种主要的方法调用形式：分派调用则较复杂，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。两两组合就有了四种分派组合情况。

#### 分派

Java有三种不同了分派机制，[静态分派](#静态分派)、[动态分派](#动态分派)和[方法句柄分派](#javalanginvoke包)。

##### 静态分派

`Human man=new Man();`  
Human称为变量的静态类型或外观类型，Man称为变量的实际类型或运行时类型。静态类型和实际类型在程序中都可能发成变化，区别是  
静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的在编译器是可知的。而实际类型变化的结果在运行期才可以确定，编译期并不知道就一个对象的实际类型是什么。  
强转不会改变原来变量的静态类型，静态类型与实际类型不一定相同，实际类型可以是静态类型的子类或实现类。

在方法接收者已经确定的前提下，使用哪个重载版本的取决于传入参数的数量和数据类型，**虚拟机（或者说编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据。**
由于静态类型在编译器可知，所以在编译阶段，javac编译器就根据参数的静态类型决定了使用哪个重载版本。

**所有依赖静态类型来决定方法执行版本的分派动作都称为静态分派。静态分派的最典型应用表现就是方法重载。**
静态分派发生在编译阶段，即确定静态分派的动作实际上不是有虚拟机来执行的，所以有些资料会把它归入解析。  
需要注意javac编译器虽然能确定出方法的重载版本，但在很多情况下重载版本并不是唯一的，往往只能确定一个相对合适的版本。
之所以相对合适是因为**字面量天生的模糊性，它不需要定义，没有显式的静态类型，它的静态类型只能通过语言、语法和规则去理解和推断**。  
例 ‘a’是一个char类型的数据，还可以代表数字97，进一步转型为长整型97L; ‘a’可以封装为java.lang.Character,进一步为Character的接口java.lang.Serializable;Object；可变长类型。

##### 动态分派

根据《Java虚拟机规范》invokevirtual指令的运行时解析过程为

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
2. 如果在类型C中找到了与常量中的描述符和简单名称都符合的方法，则进行访问权限校验，通过则返回该方法的直接引用，失败抛异常。
3. 如果找不到，按照继承关系从下往上以此对C的各个父类进行第二步。
4. 始终找不到抛异常。

**invokevirtual指令的执行的第一步就是在运行期确定接收者的实际类型，所以invokevirtual指令并不是把常量池中的方法引用解析到直接引用上就结束了，
还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言方法重写的本质。  
把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。**

在Java里面只有虚方法存在，字段永远不可能是虚的，即字段永远不参与多态。哪个类的方法访问的某个名字的字段时，改名字指的就是这个类能看到的那个字段。
当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。
理解代码`org.fenixsoft.jvm.chapter8.FieldHasNoPolymorphic.main`

##### 单分派与多分派

方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。  
单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

如今的Java语言是一个静态多分派、动态单分派的语言。
> 个人理解：方法的接收者是一种宗量，方法的参数是一种宗量，Java中目前就考虑这两种宗量。  
> 静态分派即在编译阶段 因为存在方法重载 所以选择目标方法要依据方法的接收者和方法的参数两种宗量来决定调用哪个方法，即静态是多分派。  
> 动态分派即在运行阶段 因为存在方法重写 所以在编译阶段已经确定过的前提下 还需要依据方法接收者的实际类型来决定调用哪个方法，即动态分派是单分派。  
> 即 静态分派是从重载中确定方法要考虑方法接收者和方法参数，动态分派是从重写中确定方法只考虑方法接收者。

##### 虚拟机动态分派的实现

动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地反复搜索类型元数据。  
常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table：vtable）使用虚方法表索引来代替元数据查找以提高性能。  
虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类的相同方法的地址入口是一致的，都指向父类的实现入口。  
如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。

为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型转换时，仅需要变更要查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。  
虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。

### 动态类型语言支持

JDK7时引入invokedynamic指令以及java.lang.invoke包。

#### 动态类型语言

动态类型语言的关键特征是它的**类型检查的主体过程**实在运行期而不是编译器进行的。满足这个特征的语言有 APL、Erlang、JavaScript、Python、Smalltalk等。  
相对地，在编译器就进行类型检查的语言有c++、Java等。

* 举例1：Java代码`int[][][] array=new int[1][0][-1];`  
  该Java代码可以编译，但运行时有异常，即**运行时异常**就是指只要代码不执行到这一行就不会出现问题。  
  与运行时异常相对应的概念是**连接时异常**，即使把导致连接时异常的代码放在一条根本不会执行的路径上，类加载时也照样抛出异常。  
  **一门语言的哪一种检查行为要在运行期进行，哪一种检查行为要在编译器进行并没有什么必然的因果逻辑关系，关键是在语言规范中人为设立的约定。**
* 举例2：`obj.println("hello world");`  
  假设是Java代码，并且obj的静态类型是java.io.PrintStream 那变量obj的实际类型就必须是PrintStream的子类才是合法的。哪怕obj属于一个确有包含println(String)方法相同方法签名的类型，但只要不是java.io.PrintStream的子类，代码依然不可能运行——类型检查不合法。  
  假设是JavaScript则不一样，无论obj具体是何种类型，无论其继承关系如何，只要这种类型的方法定义中确有println(String)相同签名的方法，便可调用。  
  产生这种差别的根本原因是Java语言在编译期已将println(String)方法完整的符号引用生成出来，并作为方法调用指令的参数存储到Class文件中，
  这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。  
  JavaScript等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，变量obj的值才具有类型，所以编译器在编译时最多只能确定方法名称、参数、返回值，而不会去确定方法所在的具体类型（即方法接收者不确定）。  
  “**变量无类型而变量值才有类型**”这个特点也是动态类型语言的一个核心特征。

静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大规模。  
动态类型语言在运行期才确定类型，可以为开发者提供极大的灵活性，某些功能比静态类型语言更简洁，也意味着开发效率提升。

#### java.lang.invoke包

该包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一条新的动态确定目标方法的机制，称为“方法句柄”。参考[MethodHandleTest.java](MethodHandleTest.java)

* Reflection和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。  
  在MethodHandle.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正式为了对应invokestatic、invokevirtual（invokeinterface）、invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection的API时时不需要关心的。
* Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。  
  前者是方法在Java端的全面映像包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。  
  后者仅包含执行该方法的相关信息。即 Reflection是重量级的，MethodHandle是轻量级的。
* 由于MethodHandle是对字节码的方法指令调用的模拟，理论上虚拟机在这方面做的各种优化，在MethodHandle上也应当采用类似的思路去支持，而通过反射去调用方法则几乎不可能去实施各类调用点优化措施。
* Reflection API的设计目标只为了Java语言服务，MethodHandle可服务于所有Java虚拟机上的语言。

#### invokedynamic指令

某种意义上invokedynamic指令与MethodHandle机制的作用时一样的，都是为了解决原有四条"invoke*"指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码上，让用户有更高的自由度。  
只是一个用上层代码和API来实现，另一个用字节码和CLass中其他属性、常量来完成。

invokedynamic指令面向的主要服务对象并非Java语言，而是其他Java虚拟机之上的动态类型语言。

### 基于栈的字节码解释执行引擎

许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行和编译执行两种。

#### 解释执行

Java语言经常被定位为“解释执行”的语言，在JDK1.0还可以，当主流的虚拟机都包含了即时编译器后，Class文件中的代码到底是被解释执行还是编译执行，要看具体的虚拟机。在后来Java发展出了直接生成本地代码的编译器，解释执行对于Java语言来说几乎没意义，  
只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式，谈解释执行还是编译执行才有意义。

传统编译原理中程序代码到目标机器代码的生成过程：程序源码->词法分析->单词流->语法分析->抽象语法树->抽象语法树->指令流->解释器->解释执行  
解释执行过程：程序源码->词法分析->单词流->语法分析->抽象语法树->优化器->中间代码->生成器->目标代码

对于一门具体的语言，词法、语法分析一致后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。  
也可以选择把一部分步骤实现为一个半独立的编译器，这类代表是Java语言。  
或者把这些步骤和执行引擎全部封装到一个封闭的黑匣子，入大多数JavaScript执行引擎。

在Java语言中，javac的编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译是半独立的实现。

#### 基于栈的指令集和基于寄存器的指令集

基于栈的指令集主要优点是可移植性，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器不可避免地要受到硬件的约束。代码相对更加紧凑，编译器实现更加简单。  
缺点是理论上执行速度相对稍慢，在解释执行时，栈架构指令集代码虽然紧凑，但完成相同功能所需的指令一般比寄存器架构多，因为出栈、入栈操作本身就产生大量的指令。
更重要的是栈实现在内存中，频繁的栈访问也意味着频繁的内存访问，导致栈架构指令集的执行速度会相对慢一些。如果经过即时编译器输出成物理机上的汇编指令流相对就一样了。
