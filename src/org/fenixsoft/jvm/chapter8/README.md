## 虚拟机字节码执行引擎

执行引擎是Java虚拟机核心的组成部分之一。  
”虚拟机“是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，
而虚拟机的执行引擎是由软件实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，栈帧则是支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
每一个方法从调用开始至执行结束的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、操作数栈、动态连接和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入方法表的Code属性中。

一个线程中的方法调用链可能会很长，以Java的角度来看，同一时刻，同一条线程里面，在调用堆栈的所有方法都是同时处于执行状态。  
而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。  
执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。

#### 局部变量表

是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
在Java程序被编译为Class文件的时候，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。  
局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据。
这八种数据类型都可以使用32位或更小的物理内存来存储，但这种描述与明确指出“每个变量槽应占用32位长度的内存空间”有本质差别，**它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化**，
保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。**如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用**，在方法中可以通过关键字this来访问这个隐含的参数。  
其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

局部变量表中的变量槽是可以重复使用的方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码的PC计数器的值已经超过了某个变量的作用域，该变量对应的变量槽就可以交给其他变量来重用。
（有时候虽然出了变量的作用域以后触发垃圾回收，变量如果没有被重用可能还在变量槽中，该变量指向的实例也是不会被回收的。局部变量表属于GC Root）

#### 操作数栈

操作数栈的最大深度在编译时被写入到Code属性的max_stacks数据项中，操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位占栈容量1，64位占2。  
当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈。  
操作数栈中元素的数据类型与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要在验证一次。  
在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全独立的。但在大多数虚拟机的实现里都会进行一些优化，令两个栈帧出现一部分重叠。
让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，不仅节约了一些空间，更是在进行方法调用的时可以直接共用一部分数据，无须进行额外的参数赋值传递。

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。  
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。  
这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。  
另一部分将在每一次运行期间都转化为直接引用，这部分称为**动态连接**。

#### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法。

1. 正常调用完成：执行引擎遇到任意一个方法返回的字节码指令，此时可能会有返回值传递给上层的方法调用者，方法是否有返回此以及返回值的类型将根据遇到的返回指令来决定。
2. 异常调用完成：在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常还是代码使用字节码指令产生的异常，只要在本地方法异常表中没有搜索到匹配的处理器，就会导致方法的退出。  
   不会给它的上层调用者提供返回值。

无论何种退出方式，在方法退出后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法方法返回时可能需要在栈帧中赵存一些信息，用来帮助恢复它的上层方法调用者的执行状态。

#### 附加信息

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有的描述信息到栈帧中，例如与调试，性能收集相关的信息。  
在讨论概念时，一般会把动态连接，方法返回地址与其他附加信息统称为栈帧信息。

### 方法调用

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法的具体运行过程。  
Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。  
这个特性给Java带来了更强大的动态扩展能力，但也使Java方法的调用过程更复杂，某些调用需要在类加载期间，甚至到运行时才能确定目标方法的直接引用。

#### 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在列加载解析阶段，会将一部分符号引用转化为直接引用，这部分需要满足：  
方法在程序运行之前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可变的。即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析。

在Java语言中符合”编译器可知，运行期不可变“的方法主要有：静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特性决定了它们都不可能通过继承或别的方式被重写。

调用不同类型的方法，字节码指令集里设计了不同的指令。

* invokestatic:调用静态方法
* invokespecial:调用实例构造器<init>()方法，私有方法和父类中的方法。
* invokevirtual:调用所有的虚方法
* invokeinterface:调用接口方法，会在运行时在确定一个实现该接口的对象。
* invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。其他四条指令的分派逻辑固化在虚拟机内部。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合的有静态方法、私有方法、实例构造器、父类方法四种，
再加上被final修饰的方法（即使它使用invokevirtual指令调用），**这五种方法调用时会在类加载的时候就可以把符号引用解析为该方法的直接引用。 这些方法统称为”非虚方法“，与之相反其他方法被称为”虚方法“**。

**解析调用一定是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。**  
另一种主要的方法调用形式：分派调用则较复杂，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。两两组合就有了四种分派组合情况。

#### 分派

##### 静态分派

`Human man=new Man();`  
Human称为变量的静态类型或外观类型，Man称为变量的实际类型或运行时类型。静态类型和实际类型在程序中都可能发成变化，区别是  
静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的在编译器是可知的。而实际类型变化的结果在运行期才可以确定，编译期并不知道就一个对象的实际类型是什么。  
强转不会改变原来变量的静态类型，静态类型与实际类型不一定相同，实际类型可以是静态类型的子类或实现类。

在方法接收者已经确定的前提下，使用哪个重载版本的取决于传入参数的数量和数据类型，**虚拟机（或者说编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据。**
由于静态类型在编译器可知，所以在编译阶段，javac编译器就根据参数的静态类型决定了使用哪个重载版本。

**所有依赖静态类型来决定方法执行版本的分派动作都称为静态分派。静态分派的最典型应用表现就是方法重载。**
静态分派发生在编译阶段，即确定静态分派的动作实际上不是有虚拟机来执行的，所以有些资料会把它归入解析。  
需要注意javac编译器虽然能确定出方法的重载版本，但在很多情况下重载版本并不是唯一的，往往只能确定一个相对合适的版本。
之所以相对合适是因为**字面量天生的模糊性，它不需要定义，没有显式的静态类型，它的静态类型只能通过语言、语法和规则去理解和推断**。  
例 ‘a’是一个char类型的数据，还可以代表数字97，进一步转型为长整型97L; ‘a’可以封装为java.lang.Character,进一步为Character的接口java.lang.Serializable;Object；可变长类型。

##### 动态分派

根据《Java虚拟机规范》invokevirtual指令的运行时解析过程为

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
2. 如果在类型C中找到了与常量中的描述符和简单名称都符合的方法，则进行访问权限校验，通过则返回该方法的直接引用，失败抛异常。
3. 如果找不到，按照继承关系从下往上以此对C的各个父类进行第二步。
4. 始终找不到抛异常。

**invokevirtual指令的执行的第一步就是在运行期确定接收者的实际类型，所以invokevirtual指令并不是把常量池中的方法引用解析到直接引用上就结束了，
还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言方法重写的本质。  
把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。**

在Java里面只有虚方法存在，字段永远不可能是虚的，即字段永远不参与多态。哪个类的方法访问的某个名字的字段时，改名字指的就是这个类能看到的那个字段。
当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。
理解代码`org.fenixsoft.jvm.chapter8.FieldHasNoPolymorphic.main`

##### 单分派与多分派

方法的接收者与参数统称为方法的宗量。  
单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

如今的Java语言是一个静态多分派、动态单分派的语言。我理解为 编译前写代码重载可以多个，运行时运行哪个不论重写多少只运行一个。即静态是对方法，动态是对运行时对象。

##### 虚拟机动态分派的实现

动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地反复搜索类型元数据。  
常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table：vtable）使用虚方法表索引来代替元数据查找以提高性能。  
虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类的相同方法的地址入口是一致的，都指向父类的实现入口。  
如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。

为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型转换时，仅需要变更要查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。  
虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。