## 虚拟机字节码执行引擎

执行引擎是Java虚拟机核心的组成部分之一。  
”虚拟机“是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，
而虚拟机的执行引擎是由软件实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，栈帧则是支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
每一个方法从调用开始至执行结束的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、操作数栈、动态连接和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入方法表的Code属性中。

一个线程中的方法调用链可能会很长，以Java的角度来看，同一时刻，同一条线程里面，在调用堆栈的所有方法都是同时处于执行状态。  
而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。  
执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。

#### 局部变量表

是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
在Java程序被编译为Class文件的时候，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。  
局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据。
这八种数据类型都可以使用32位或更小的物理内存来存储，但这种描述与明确指出“每个变量槽应占用32位长度的内存空间”有本质差别，**它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化**，
保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。**如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用**，在方法中可以通过关键字this来访问这个隐含的参数。  
其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

局部变量表中的变量槽是可以重复使用的方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码的PC计数器的值已经超过了某个变量的作用域，该变量对应的变量槽就可以交给其他变量来重用。
（有时候虽然出了变量的作用域以后触发垃圾回收，变量如果没有被重用可能还在变量槽中，该变量指向的实例也是不会被回收的。局部变量表属于GC Root）

#### 操作数栈

操作数栈的最大深度在编译时被写入到Code属性的max_stacks数据项中，操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位占栈容量1，64位占2。  
当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈。  
操作数栈中元素的数据类型与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要在验证一次。  
在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全独立的。但在大多数虚拟机的实现里都会进行一些优化，令两个栈帧出现一部分重叠。
让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，不仅节约了一些空间，更是在进行方法调用的时可以直接共用一部分数据，无须进行额外的参数赋值传递。

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。  
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。  
这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。  
另一部分将在每一次运行期间都转化为直接引用，这部分称为**动态连接**。

#### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法。

1. 正常调用完成：执行引擎遇到任意一个方法返回的字节码指令，此时可能会有返回值传递给上层的方法调用者，方法是否有返回此以及返回值的类型将根据遇到的返回指令来决定。
2. 异常调用完成：在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常还是代码使用字节码指令产生的异常，只要在本地方法异常表中没有搜索到匹配的处理器，就会导致方法的退出。  
   不会给它的上层调用者提供返回值。

无论何种退出方式，在方法退出后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法方法返回时可能需要在栈帧中赵存一些信息，用来帮助恢复它的上层方法调用者的执行状态。

#### 附加信息

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有的描述信息到栈帧中，例如与调试，性能收集相关的信息。  
在讨论概念时，一般会把动态连接，方法返回地址与其他附加信息统称为栈帧信息。

### 方法调用

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法的具体运行过程。  
Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。  
这个特性给Java带来了更强大的动态扩展能力，但也使Java方法的调用过程更复杂，某些调用需要在类加载期间，甚至到运行时才能确定目标方法的直接引用。

#### 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在列加载解析阶段，会将一部分符号引用转化为直接引用，这部分需要满足：  
方法在程序运行之前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可变的。即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析。

在Java语言中符合”编译器可知，运行期不可变“的方法主要有：静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特性决定了它们都不可能通过继承或别的方式被重写。

调用不同类型的方法，字节码指令集里设计了不同的指令。

* invokestatic:调用静态方法
* invokespecial:调用实例构造器<init>()方法，私有方法和父类中的方法。
* invokevirtual:调用所有的虚方法
* invokeinterface:调用接口方法，会在运行时在确定一个实现该接口的对象。
* invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。其他四条指令的分派逻辑固化在虚拟机内部。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合的有静态方法、私有方法、实例构造器、父类方法四种，
再加上被final修饰的方法（即使它使用invokevirtual指令调用），**这五种方法调用时会在类加载的时候就可以把符号引用解析为该方法的直接引用。 这些方法统称为”非虚方法“，与之相反其他方法被称为”虚方法“**。

解析调用一定是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。  
另一种主要的方法调用形式：分派调用则较复杂，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。两两组合就有了四种分派组合情况。

