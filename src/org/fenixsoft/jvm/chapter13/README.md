## 线程安全与锁优化

面向过程的编程思想：把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，站在计算机的角度去抽象问题和解决问题。
面向对象的编程思想：把数据和行为看作对象的一部分，站在现实世界的角度去抽象和解决问题。

### Java语言中的线程安全

按照线程安全的强度由弱至强，可以将Java语言中的各种操作共享的数据分为：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。

* 不可变：在Java语言里面，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者。  
  Java语言中，如果多线程共享的数据是一个基本数据类型，只要定义是使用final关键字修饰就可以保证它是不可变的。  
  如果共享数据是一个对象，由于Java语言目前还没有提供值类型的支持，需要对象自行保**证其行为不会对其状态产生任何影响**才行。最简单的一种就是把对象里面带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。
* 绝对线程安全：不管运行时坏境如何，调用者都不需要任何额外的同步措施。在JavaAPI中标注自己是线程安全的类，大多数都不是绝对安全的。
* 相对线程安全：通常意义上的线程安全，需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外保障措施，对于一些特定的连续调用，可能需要在调用端使用额外的同步手段来保证调用的正确性。
* 线程兼容：对象本身并不是线程安全的，可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。JavaAPI大部分类都是线程兼容的。
* 线程对立：不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，Java中这种代码很少出现，而且通常都是有害的，应尽量避免。

### 线程安全的实现方法

#### 互斥同步（阻塞同步）

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段，互斥是方法，同步是目的。  
互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也叫阻塞同步。

synchronized关键字经过javac编译后，会在同步块前后端形成monitorenter和monitorexit两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。
如果Java源码中synchronized明确制定了对象参数，那就以这个对象的引用作为reference；
**如果没有明确指定，将根据synchronized修饰的方法类型来决定取代码所在的实例还是取类型对应的Class对象<u>作为线程持有的锁</u>**。  
synchronized是Java语言中一个重量级操作，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，就不可避免地陷入用户态到核心态的转换中，这种状态转换需要耗费恨过的处理器时间。

Java类库提供了java.util.concurrent包，其中`java.util.concurrent.locks.Lock`接口是Java的另一种互斥同步手段，
基于Lock接口，用户能够以非快结构来实现同步，从而摆脱语言特性的束缚，改为在类库层面去实现同步。  
重入锁（ReentrantLock）是Lock接口最常见的一种实现，它与synchronized一样是可重入的，增加了一些高级功能。

* 等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。
* 公平锁：多个线程等待同一个锁时，必须按照申请锁的顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。
  synchronized是非公平的，ReentrantLock默认是非公平的，可以设置为使用公平锁，会导致性能急剧下降。
* 绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。
  在synchronized中，锁对象的wait()跟notify()或notifyAll()方法配合可以实现一个隐含的条件，如果要多余一个条件的关联，就不得不额外添加一个锁；
  而ReentrantLock只需要多次调用newCondition方法即可。

ReentrantLock在功能上是synchronized的超集都可满足时优先使用synchronized。

1. synchronized实在Java语法层面的同步，清晰，简单。在只需要基本的同步功能时，优先synchronized。
2. Lock应该确保在finally块中释放锁，这一点需要程序员来保证。synchronized由Java虚拟机来保证。
3. 从长远来看，Java虚拟机更容易针对synchronized进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用Lock的话Java虚拟机很难得知具体哪些锁对象是由特定线程持有的。

#### 非阻塞同步

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也叫阻塞同步。  
从解决问题的方式上看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施，就肯定会出现问题，无论共享数据是否真的会出现竞争，它都会进行加锁，这将导致用户态到核心态的转换、维护锁计数器、检查是否有被阻塞的线程需要被唤醒等开销。

随着硬件指令的发展，多了一种：基于冲突检测的乐观并发策略，即不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就成功；否则 进行其他的补偿措施。这种乐观并发策略的实现不需要把线程阻塞挂起，因此这种同步操作称为非阻塞同步。  
该策略要求操作和冲突检测这两个步骤具备原子性，由硬件来实现。硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这样的指令有

* 测试并设置（Test-and-Set）
* 获取并增加（Fetch-and-Increment）
* 交换（Swap）
* 比较并交换（Compare-and-Swap，CAS）
* 加载链接/条件存储（Load-Linked/Store-Conditional，LL/SC）

Java里面最终暴露出来的是CAS操作。  
CAS操作需要有三个操作数，分别是内存位置V，旧的预期值A，准备设置的新值B。  
CAS执行时，当且仅当V符合A时，处理器才会用B更新V，否则它就不执行更新。无论是否更新都会返回V的旧值。CAS是一个原子操作，执行期间不会被其他线程中断。

CAS存在一个逻辑漏洞，如果一个变量V初次读取的时候是A，并且在准备赋值的时候检查仍然是A，如果在这段期间它的值被改为B又被改为A，CAS操作就会误认为它从来没有被改变过，正常执行更新。这个漏洞称为CAS操作的”**ABA问题**“。  
JUC提了一个带有标记的原子引用类`java.util.concurrent.atomic.AtomicStampedReference`,它可以通过控制变量值的版本来保证CAS的正确性，不过目前这个类比较鸡肋。大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。

#### 无同步方案

要保证线程安全，并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必要的联系。**同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本身就不涉及共享数据，那它就自然不需要任何同步措施去保证其正确性**。

可重入代码又纯代码：指可以在代码执行的任何时刻打断它，转而去执行另外一段代码，而在控制权返还后，原来的程序不会出现任何错误，也不会对结果有所影响。可重入代码有一些共同特征：不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入、不调用非可重入的方法。

线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，这些共享数据的代码是否能保证在同一个线程中执行。如果可以把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用问题。  
大部分使用消费队列的架构模式都会将产品的消费过程限制在一个线程中完成。

### 锁优化

高校并发是从JDK5升级到JDK6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本花费了大量的资源去实现锁优化技术。

#### 自旋锁与自适应锁

互斥同步对性能最大的影响时阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。  
在许多应用上，共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得，如果物理机有多个处理器可以让不止一个线程并行执行，就可以让后面请求锁的哪个线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程能否很快释放锁。
为了让线程等待，只需让线程执行一个忙循环，这项技术就是自旋锁。

自旋锁本身虽然避免了线程切换的开销，但它要占用处理器的时间，如果被占用的时间短，自旋等待效果比较好，否则会白白消耗处理器资源。  
因此自旋等待时间必须有一定限度，超过了规定次数仍然没有获得锁，就应当使用传统方式去挂起线程。自旋次数默认10次。

JDK6对自旋锁优化引入了自适应的自旋：自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。  
如果在同一个锁上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能会成功，进而允许自旋等待持续相对更长时间。  
如果对于某个锁，自旋很少获得过锁，后面可能直接省略掉自旋过程。

#### 锁消除

锁消除指**虚拟机即时编译器在运行时**，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除

#### 锁粗化

如果一系列的操作都对同一个对象反复加锁解锁，甚至出现在循环体中，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能耗损。如果虚拟机探测到有这样一系列的操作，将会把锁同步到范围扩展到整个操作序列的外部。

#### 轻量级锁

轻量级时相对于操作系统互斥量来实现的传统锁而言。  
轻量级锁并不是用来代替重量级锁，设计的初衷是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。

HptSpot虚拟机的对象头分为两部分  
第一部分用于存储对象自身的运行时数据，官方称为”Mark Word“  
第二部分用于存储指向方法区对象类型数据的指针，如果时数组对象，还会有一个额外的部分用于存储数组的长度。

由于对象头信息是与对象自身定义无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间存储尽量多的信息，它会根据对象的状态复用自己的存储空间。
<table >
<caption>HotSpot虚拟机对象头Mark Word</caption>
<thead>
<tr><th rowspan="3">锁状态</th><th colspan="5">32bit</th></tr>
<tr><th colspan="2">25bit</th><th rowspan="2">4bit</th><th>1bit</th><th>2bit</th></tr>
<tr><th>23bit</th><th>2bit</th><th>偏向模式</th><th>标志位</th></tr>
</thead>
<tbody>
<tr><td>未锁定</td><td colspan="2">对象哈希码</td><td>分代年龄</td><td>0</td><td>01</td></tr>
<tr><td>轻量级锁定</td><td colspan="4">指向调用栈中锁记录的指针</td><td>00</td></tr>
<tr><td>重量级锁定</td><td colspan="4">指向重量级锁的指针</td><td>10</td></tr>
<tr><td>GC标记</td><td colspan="4">空</td><td>10</td></tr>
<tr><td>可偏向</td><td>线程ID</td><td>Epoch</td><td>分代年龄</td><td>1</td><td>01</td></tr>
</tbody>
</table>

在32位的HotSpot的虚拟机中，对象未被锁定的状态，Mark Word的32个比特空间里的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0.  
对象除了未锁定的正常状态外，还有轻量级锁定，重量级锁定，GC标记，可偏向这几种不同的状态。

在代码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为01)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝。
然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针，即指向调用栈中锁记录的指针，
如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位转变为00，表示此对象处于轻量级锁定状态。

如果这个更新操作失败，意味着至少存在一个线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，
否则说明这个锁对象已经被其他线程抢占了。  
如果出现两条以上的线程争用 一个锁的情况，轻量级锁就不再有效，必须膨胀为重量级锁，锁标志变为10，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针。

轻量级锁提升同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁通过CAS操作避免了使用互斥量的开销，但如果存在竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销，反而比重量级锁更慢。

#### 偏向锁

偏向锁的目的是消除数据在无竞争情况下同步原语，进一步提高程序的运行性能。

如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做。

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要在进行同步。一旦另外一个线程去尝试获取这个锁的情况，偏向模式就马上结束。
根据锁对象目前是否处于被锁定状态决定是否撤销偏向（偏向模式设置为0），撤销后标志位恢复到未锁定01或轻量级锁00的状态，后续的同步操作就按照轻量级锁那样去执行。

偏向锁可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。